
小程序支付 https://www.jianshu.com/p/209b9dce0c8d
	https://cloud.tencent.com/edu/learning/

 https://github.com/macrozheng/mall 电商系统
 
聊聊面试中的 Java 线程池 https://mp.weixin.qq.com/s/U9Ksm7fZr5ANNCSYiaulow
没那么简单的线程池 https://mp.weixin.qq.com/s/DJPuYVhRGRXkkUGMuDdrSw
















分布式事物
分布式事物的存在，就是解决数据不一致的情况。
分布式系统中有这么一个广为流传的理论：CAP 定理
对于一个分布式计算系统来说，不可能同时满足以下三点：
	•一致性（Consistency）
	•可用性（Availability）
	•分区容错性（Partition tolerance）
由于分区容错性（P）是必须保证的，那么我们分布式系统就更多是在一致性（CP） 和可用性（AP）上做平衡了，只能同时满足两个条件。
其实，大家想想，ZK 是不是就是严格实现了 CP ，而 Eureka 则是保证了 AP。

其实分布式事物强调的就是一致性。

分布式调用中超时时间太长的问题
通信协议上要有版本号
在服务框架切换为Mina的版本上线后，发布服务的应用重启时出现一个问题，就是发现重启后集群中的机器负载严重不均，排查发现是由于这个版本采用是服务的调用方会通过硬件负载均衡去建立到服务发布方的连接，而且是单个的长连接，由于是通过硬件负载均衡建连，意味着服务调用方其实看到的都是同一个地址，这也就导致了当服务发布方重启时，服务调用方重连就会集中的连到存活的机器上，连接还是长连，因此就导致了负载的不均衡现象。
服务框架在做了一年多以后，某个版本中出现了一个严重bug，然后我们就希望能通知到用了这个版本的应用紧急升级，在这个时候悲催的发现一个问题是我们压根就不知道生产环境中哪些应用和机器部署了这个版本



无论是内部还是外部的微服务，在服务端我们都应该设计一个全局异常处理类，用来统一封装系统在抛出异常时面向调用方的返回信息。
理论上我们可以在这个全局异常处理类中，捕获处理服务接口业务层抛出的所有异常并统一响应，只是那样会让全局异常处理类变得非常臃肿，所以从最佳实践上考虑，我们一般会为内部和外部接口分别设计一个统一面向调用方的异常对象



常用的几种线程池
单个线程: Executors.newSingleThreadExecutor();
缓存线程: Executors.newCachedThreadPool();
固定线程Executors.newFixedThreadPool(2);
定时线程: Executors.newScheduledThreadPool(3);

核心 ThreadPoolExecutor
ThreadPoolExecutor 继承 AbstractExecutorService；AbstractExecutorService 实现 ExecutorService， ExecutorService 继承 Executor
public ThreadPoolExecutor(int corePoolSize,
						  int maximumPoolSize,
						  long keepAliveTime,
						  TimeUnit unit,
						  BlockingQueue<Runnable> workQueue,
						  ThreadFactory threadFactory,
						  RejectedExecutionHandler handler) {...}
corePoolSize : 核心线程数的大小
maximumPoolSize : 线程池中允许的最大线程数
keepAliveTime : 空闲线程允许的最大的存活时间
unit : 存活时间的单位
workQueue : 阻塞任务队列
threadFactory : 线程工厂用来创建线程
handler : 拒绝策略，针对当队列满了时新来任务的处理方式

源码分析
根据源码可以发现整个线程池大致分为 3 个部分，1. 是创建 worker 线程，2. 添加任务到 workQueue; 3.worker 线程执行具体任务



























































































































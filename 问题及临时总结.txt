
小程序支付 https://www.jianshu.com/p/209b9dce0c8d
	https://cloud.tencent.com/edu/learning/

 https://github.com/macrozheng/mall 电商系统
多线程的实现方式有哪些？
描述一些线程死锁的情况？
线程池的原理是什么样子？底层方法的参数分别是什么意思？
那你知道他的参数都有哪些吗 ？都分别代表什么意思吗
几个参数的意思分别为：

corePoolSize：线程池里最小线程数
maximumPoolSize：线程池里最大线程数量，超过最大线程时候会使用 RejectedExecutionHandler
keepAliveTime：线程最大的存活时间，超过这个时间就会被回收
unit：线程最大的存活时间的单位
workQueue：缓存需要执行的异步任务的队列
threadFactory：新建线程工厂
handler：拒绝策略，表示当workQueue已满，且池中的线程数达到maximumPoolSize时，线程池拒绝添加新任务时采取的策略。DiscardPolicy：抛弃当前任务，DiscardOldestPolicy：扔掉最旧的，CallerRunsPolicy：由向线程池提交任务的线程来执行该任务，AbortPolicy：抛出 RejectedExecutionException 异常。

这几种线程池在哪些情况下使用什么类型的，以及要注意什么问题，很大可能面试官会继续深挖。

mybatis 的 $ 与 # 的区别？
$ 跟 # 的使用场景 ？
mybatis 的 dao 接口跟 xml 文件里面的sql 是如何建立关系的？

mysql 锁机制 ？行锁，表锁，页面锁
排它锁 & 共享锁你了解吗 ？
mysql 索引是怎么实现的？

缓存击穿、缓存穿透 、缓存雪崩 ？
热点数据失效怎么解决？
先删缓存还是先更新数据库，为什么？是先更新数据库

kafka 的架构，包含了哪些角色？
kafka 的最小工作单元？
kafka 消息重复消费的问题？幂等怎么做的？
kafka ack 机制？集群中的ack 是怎么实现的？

Redis 中有哪些数据结构

这里面试官问 你平常有没有看过一些源码？框架的也行？JDK 的也行。


算法不要准备那么深，一般都是二分查找、排序之类的、链表、队列等等。
主要就是说你的项目，画架构图，机器部署，qps、tps都是多少。
















分布式事物
分布式事物的存在，就是解决数据不一致的情况。
分布式系统中有这么一个广为流传的理论：CAP 定理
对于一个分布式计算系统来说，不可能同时满足以下三点：
	•一致性（Consistency）
	•可用性（Availability）
	•分区容错性（Partition tolerance）
由于分区容错性（P）是必须保证的，那么我们分布式系统就更多是在一致性（CP） 和可用性（AP）上做平衡了，只能同时满足两个条件。
其实，大家想想，ZK 是不是就是严格实现了 CP ，而 Eureka 则是保证了 AP。

其实分布式事物强调的就是一致性。

分布式调用中超时时间太长的问题
通信协议上要有版本号
在服务框架切换为Mina的版本上线后，发布服务的应用重启时出现一个问题，就是发现重启后集群中的机器负载严重不均，排查发现是由于这个版本采用是服务的调用方会通过硬件负载均衡去建立到服务发布方的连接，而且是单个的长连接，由于是通过硬件负载均衡建连，意味着服务调用方其实看到的都是同一个地址，这也就导致了当服务发布方重启时，服务调用方重连就会集中的连到存活的机器上，连接还是长连，因此就导致了负载的不均衡现象。
服务框架在做了一年多以后，某个版本中出现了一个严重bug，然后我们就希望能通知到用了这个版本的应用紧急升级，在这个时候悲催的发现一个问题是我们压根就不知道生产环境中哪些应用和机器部署了这个版本



无论是内部还是外部的微服务，在服务端我们都应该设计一个全局异常处理类，用来统一封装系统在抛出异常时面向调用方的返回信息。
理论上我们可以在这个全局异常处理类中，捕获处理服务接口业务层抛出的所有异常并统一响应，只是那样会让全局异常处理类变得非常臃肿，所以从最佳实践上考虑，我们一般会为内部和外部接口分别设计一个统一面向调用方的异常对象

CAS

正在这时，Node.js悄悄地走过来， 把数据库老头儿拉走了：“前辈，别给他们一般见识，不就是扣减库存吗，用啥分布式锁！， 咱们这么做：”  

#old_num = 先获取现有的库存数量 

#new_num = #old_num - 10  

update stock set stock_num = #new_num where product_id=#product_id and stock_num = #old_num

MySQL眼前一亮， 是啊，每次把这个#old_num 作为条件传进去调用update语句，如果能成功，说明在这段时间内没有别的线程更新库存； 

如果不成功，那就重新执行这三条语句，直到成功为止， 就这个么简单， 完全不用锁，真是太爽了。 

过了几天，Tomcat他们也听说了这个方案， 惊讶地说：“这不就是我们Java常用的Compare And Set(CAS)吗？









































































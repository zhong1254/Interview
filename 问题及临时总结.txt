
小程序支付 https://www.jianshu.com/p/209b9dce0c8d
	https://cloud.tencent.com/edu/learning/

 https://github.com/macrozheng/mall 电商系统
多线程的实现方式有哪些？
描述一些线程死锁的情况？
线程池的原理是什么样子？底层方法的参数分别是什么意思？
那你知道他的参数都有哪些吗 ？都分别代表什么意思吗
几个参数的意思分别为：

corePoolSize：线程池里最小线程数
maximumPoolSize：线程池里最大线程数量，超过最大线程时候会使用 RejectedExecutionHandler
keepAliveTime：线程最大的存活时间，超过这个时间就会被回收
unit：线程最大的存活时间的单位
workQueue：缓存需要执行的异步任务的队列
threadFactory：新建线程工厂
handler：拒绝策略，表示当workQueue已满，且池中的线程数达到maximumPoolSize时，线程池拒绝添加新任务时采取的策略。DiscardPolicy：抛弃当前任务，DiscardOldestPolicy：扔掉最旧的，CallerRunsPolicy：由向线程池提交任务的线程来执行该任务，AbortPolicy：抛出 RejectedExecutionException 异常。

这几种线程池在哪些情况下使用什么类型的，以及要注意什么问题，很大可能面试官会继续深挖。

mybatis 的 $ 与 # 的区别？
$ 跟 # 的使用场景 ？
mybatis 的 dao 接口跟 xml 文件里面的sql 是如何建立关系的？

mysql 锁机制 ？行锁，表锁，页面锁
排它锁 & 共享锁你了解吗 ？
mysql 索引是怎么实现的？

缓存击穿、缓存穿透 、缓存雪崩 ？
热点数据失效怎么解决？
先删缓存还是先更新数据库，为什么？是先更新数据库

kafka 的架构，包含了哪些角色？
kafka 的最小工作单元？
kafka 消息重复消费的问题？幂等怎么做的？
kafka ack 机制？集群中的ack 是怎么实现的？

Redis 中有哪些数据结构

这里面试官问 你平常有没有看过一些源码？框架的也行？JDK 的也行。


算法不要准备那么深，一般都是二分查找、排序之类的、链表、队列等等。
主要就是说你的项目，画架构图，机器部署，qps、tps都是多少。
















分布式事物
分布式事物的存在，就是解决数据不一致的情况。
分布式系统中有这么一个广为流传的理论：CAP 定理
对于一个分布式计算系统来说，不可能同时满足以下三点：
	•一致性（Consistency）
	•可用性（Availability）
	•分区容错性（Partition tolerance）
由于分区容错性（P）是必须保证的，那么我们分布式系统就更多是在一致性（CP） 和可用性（AP）上做平衡了，只能同时满足两个条件。
其实，大家想想，ZK 是不是就是严格实现了 CP ，而 Eureka 则是保证了 AP。

其实分布式事物强调的就是一致性。

分布式调用中超时时间太长的问题
通信协议上要有版本号
在服务框架切换为Mina的版本上线后，发布服务的应用重启时出现一个问题，就是发现重启后集群中的机器负载严重不均，排查发现是由于这个版本采用是服务的调用方会通过硬件负载均衡去建立到服务发布方的连接，而且是单个的长连接，由于是通过硬件负载均衡建连，意味着服务调用方其实看到的都是同一个地址，这也就导致了当服务发布方重启时，服务调用方重连就会集中的连到存活的机器上，连接还是长连，因此就导致了负载的不均衡现象。
服务框架在做了一年多以后，某个版本中出现了一个严重bug，然后我们就希望能通知到用了这个版本的应用紧急升级，在这个时候悲催的发现一个问题是我们压根就不知道生产环境中哪些应用和机器部署了这个版本



无论是内部还是外部的微服务，在服务端我们都应该设计一个全局异常处理类，用来统一封装系统在抛出异常时面向调用方的返回信息。
理论上我们可以在这个全局异常处理类中，捕获处理服务接口业务层抛出的所有异常并统一响应，只是那样会让全局异常处理类变得非常臃肿，所以从最佳实践上考虑，我们一般会为内部和外部接口分别设计一个统一面向调用方的异常对象

CAS

正在这时，Node.js悄悄地走过来， 把数据库老头儿拉走了：“前辈，别给他们一般见识，不就是扣减库存吗，用啥分布式锁！， 咱们这么做：”  

#old_num = 先获取现有的库存数量 

#new_num = #old_num - 10  

update stock set stock_num = #new_num where product_id=#product_id and stock_num = #old_num

MySQL眼前一亮， 是啊，每次把这个#old_num 作为条件传进去调用update语句，如果能成功，说明在这段时间内没有别的线程更新库存； 

如果不成功，那就重新执行这三条语句，直到成功为止， 就这个么简单， 完全不用锁，真是太爽了。 

过了几天，Tomcat他们也听说了这个方案， 惊讶地说：“这不就是我们Java常用的Compare And Set(CAS)吗？



String 类和常量池
String 对象的两种创建方式：
String str1 = "abcd";
String str2 = new String("abcd");
这两种不同的创建方法是有差别的，第一种方式是在常量池中拿对象，第二种方式是直接在堆内存空间创建一个新的对象。只要使用new方法，便需要创建新的对象。

String 类型的常量池比较特殊。它的主要使用方法有两种：
•直接使用双引号声明出来的 String 对象会直接存储在常量池中。
•如果不是用双引号声明的 String 对象，可以使用 String 提供的 intern 方法。String.intern() 是一个 Native 方法，它的作用是：如果运行时常量池中已经包含一个等于此 String 对象内容的字符串，则返回常量池中该字符串的引用；如果没有，则在常量池中创建与此 String 内容相同的字符串，并返回常量池中创建的字符串的引用。
          String s1 = new String("计算机");
          String s2 = s1.intern();
          String s3 = "计算机";
          System.out.println(s2);//计算机
          System.out.println(s1 == s2);//false，因为一个是堆内存中的String对象一个是常量池中的String对象，
          System.out.println(s3 == s2);//true，因为两个都是常量池中的String对象

String 字符串拼接
          String str1 = "str";
          String str2 = "ing";

          String str3 = "str" + "ing";//常量池中的对象
          String str4 = str1 + str2; //在堆上创建的新的对象      
          String str5 = "string";//常量池中的对象
          System.out.println(str3 == str4);//false
          System.out.println(str3 == str5);//true
          System.out.println(str4 == str5);//false

String s1 = new String("abc");这句话创建了几个对象？
创建了两个对象:先有字符串"abc"放入常量池，然后 new 了一份字符串"abc"放入Java堆(字符串常量"abc"在编译期就已经确定放入常量池，而 Java 堆上的"abc"是在运行期初始化阶段才确定)，然后 Java 栈的 str1 指向Java堆上的"abc"。


8种基本类型的包装类和常量池

•Java 基本类型的包装类的大部分都实现了常量池技术，即Byte,Short,Integer,Long,Character,Boolean；这5种包装类默认创建了数值[-128，127]的相应类型的缓存数据，但是超出此范围仍然会去创建新的对象。
•两种浮点数类型的包装类 Float,Double 并没有实现常量池技术。
        Integer i1 = 33;
        Integer i2 = 33;
        System.out.println(i1 == i2);// 输出true
        Integer i11 = 333;
        Integer i22 = 333;
        System.out.println(i11 == i22);// 输出false
        Double i3 = 1.2;
        Double i4 = 1.2;
        System.out.println(i3 == i4);// 输出false

应用场景：

•Integer i1=40；Java 在编译的时候会直接将代码封装成Integer i1=Integer.valueOf(40);，从而使用常量池中的对象。
•Integer i1 = new Integer(40);这种情况下会创建新的对象。
Integer i1 = 40;
Integer i2 = new Integer(40);
System.out.println(i1==i2);//输出false


Integer比较更丰富的一个例子:
  Integer i1 = 40;
  Integer i2 = 40;
  Integer i3 = 0;
  Integer i4 = new Integer(40);
  Integer i5 = new Integer(40);
  Integer i6 = new Integer(0);

  System.out.println("i1=i2   " + (i1 == i2));
  System.out.println("i1=i2+i3   " + (i1 == i2 + i3));
  System.out.println("i1=i4   " + (i1 == i4));
  System.out.println("i4=i5   " + (i4 == i5));
  System.out.println("i4=i5+i6   " + (i4 == i5 + i6));   
  System.out.println("40=i5+i6   " + (40 == i5 + i6));    
结果：
i1=i2   true
i1=i2+i3   true
i1=i4   false
i4=i5   false
i4=i5+i6   true
40=i5+i6   true
语句i4 == i5 + i6，因为+这个操作符不适用于Integer对象，首先i5和i6进行自动拆箱操作，进行数值相加，即i4 == 40。然后Integer对象无法与数值进行直接比较，所以i4自动拆箱转为int值40，最终这条语句转为40 == 40进行数值比较。



























































































